// Generated by Microsoft TypeSpec

import * as http from "node:http";

import * as serverRaw from "./operations/server-raw.js";

import {
  Pets,
  PetCheckups,
  PetInsurance,
  Toys,
  ToyInsurance,
  Checkups,
  Owners,
  OwnerCheckups,
  OwnerInsurance,
} from "../models/all/pet-store.js";

import {
  RouterOptions,
  createPolicyChain,
  createPolicyChainForRoute,
  HttpContext,
} from "../helpers/router.js";

export interface PetStoreRouter {
  /**
   * Dispatches the request to the appropriate service based on the request path.
   *
   * This member function may be used directly as a handler for a Node HTTP server.
   *
   * @param request - The incoming HTTP request.
   * @param response - The outgoing HTTP response.
   */
  dispatch(request: http.IncomingMessage, response: http.ServerResponse): void;

  /**
   * An Express middleware function that dispatches the request to the appropriate service based on the request path.
   *
   * This member function may be used directly as an application-level middleware function in an Express app.
   *
   * If the router does not match a route, it will call the `next` middleware registered with the application,
   * so it is sensible to insert this middleware at the beginning of the middleware stack.
   *
   * @param req - The incoming HTTP request.
   * @param res - The outgoing HTTP response.
   * @param next - The next middleware function in the stack.
   */
  expressMiddleware(
    req: http.IncomingMessage,
    res: http.ServerResponse,
    next: () => void,
  ): void;
}

export function createPetStoreRouter(
  pets: Pets,
  petCheckups: PetCheckups,
  petInsurance: PetInsurance,
  toys: Toys,
  toyInsurance: ToyInsurance,
  checkups: Checkups,
  owners: Owners,
  ownerCheckups: OwnerCheckups,
  ownerInsurance: OwnerInsurance,
  options: RouterOptions<{
    pets: Pets<HttpContext>;
    petCheckups: PetCheckups<HttpContext>;
    petInsurance: PetInsurance<HttpContext>;
    toys: Toys<HttpContext>;
    toyInsurance: ToyInsurance<HttpContext>;
    checkups: Checkups<HttpContext>;
    owners: Owners<HttpContext>;
    ownerCheckups: OwnerCheckups<HttpContext>;
    ownerInsurance: OwnerInsurance<HttpContext>;
  }> = {},
): PetStoreRouter {
  const onRouteNotFound =
    options.onRequestNotFound ??
    ((request, response) => {
      response.statusCode = 404;
      response.setHeader("Content-Type", "text/plain");
      response.end("Not Found");
    });

  const onInvalidRequest =
    options.onInvalidRequest ??
    ((request, response, route, error) => {
      response.statusCode = 400;
      response.setHeader("Content-Type", "application/json");
      response.end(JSON.stringify({ error }));
    });

  const onInternalError =
    options.onInternalError ??
    ((error, request, response) => {
      response.statusCode = 500;
      response.setHeader("Content-Type", "text/plain");
      response.end("Internal server error.");
    });

  const routePolicies = options.routePolicies ?? {};

  const routeHandlers = {
    pets_get: createPolicyChainForRoute(
      "petsGetDispatch",
      routePolicies,
      "pets",
      "get",
      serverRaw.pets_get,
    ),
    pets_update: createPolicyChainForRoute(
      "petsUpdateDispatch",
      routePolicies,
      "pets",
      "update",
      serverRaw.pets_update,
    ),
    pets_delete: createPolicyChainForRoute(
      "petsDeleteDispatch",
      routePolicies,
      "pets",
      "delete",
      serverRaw.pets_delete,
    ),
    pets_create: createPolicyChainForRoute(
      "petsCreateDispatch",
      routePolicies,
      "pets",
      "create",
      serverRaw.pets_create,
    ),
    pets_list: createPolicyChainForRoute(
      "petsListDispatch",
      routePolicies,
      "pets",
      "list",
      serverRaw.pets_list,
    ),
    pet_checkups_create_or_update: createPolicyChainForRoute(
      "petCheckupsCreateOrUpdateDispatch",
      routePolicies,
      "petCheckups",
      "createOrUpdate",
      serverRaw.pet_checkups_create_or_update,
    ),
    pet_checkups_list: createPolicyChainForRoute(
      "petCheckupsListDispatch",
      routePolicies,
      "petCheckups",
      "list",
      serverRaw.pet_checkups_list,
    ),
    pet_insurance_get: createPolicyChainForRoute(
      "petInsuranceGetDispatch",
      routePolicies,
      "petInsurance",
      "get",
      serverRaw.pet_insurance_get,
    ),
    pet_insurance_update: createPolicyChainForRoute(
      "petInsuranceUpdateDispatch",
      routePolicies,
      "petInsurance",
      "update",
      serverRaw.pet_insurance_update,
    ),
    toys_get: createPolicyChainForRoute(
      "toysGetDispatch",
      routePolicies,
      "toys",
      "get",
      serverRaw.toys_get,
    ),
    toys_list: createPolicyChainForRoute(
      "toysListDispatch",
      routePolicies,
      "toys",
      "list",
      serverRaw.toys_list,
    ),
    toy_insurance_get: createPolicyChainForRoute(
      "toyInsuranceGetDispatch",
      routePolicies,
      "toyInsurance",
      "get",
      serverRaw.toy_insurance_get,
    ),
    toy_insurance_update: createPolicyChainForRoute(
      "toyInsuranceUpdateDispatch",
      routePolicies,
      "toyInsurance",
      "update",
      serverRaw.toy_insurance_update,
    ),
    checkups_create_or_update: createPolicyChainForRoute(
      "checkupsCreateOrUpdateDispatch",
      routePolicies,
      "checkups",
      "createOrUpdate",
      serverRaw.checkups_create_or_update,
    ),
    checkups_list: createPolicyChainForRoute(
      "checkupsListDispatch",
      routePolicies,
      "checkups",
      "list",
      serverRaw.checkups_list,
    ),
    owners_get: createPolicyChainForRoute(
      "ownersGetDispatch",
      routePolicies,
      "owners",
      "get",
      serverRaw.owners_get,
    ),
    owners_update: createPolicyChainForRoute(
      "ownersUpdateDispatch",
      routePolicies,
      "owners",
      "update",
      serverRaw.owners_update,
    ),
    owners_delete: createPolicyChainForRoute(
      "ownersDeleteDispatch",
      routePolicies,
      "owners",
      "delete",
      serverRaw.owners_delete,
    ),
    owners_create: createPolicyChainForRoute(
      "ownersCreateDispatch",
      routePolicies,
      "owners",
      "create",
      serverRaw.owners_create,
    ),
    owners_list: createPolicyChainForRoute(
      "ownersListDispatch",
      routePolicies,
      "owners",
      "list",
      serverRaw.owners_list,
    ),
    owner_checkups_create_or_update: createPolicyChainForRoute(
      "ownerCheckupsCreateOrUpdateDispatch",
      routePolicies,
      "ownerCheckups",
      "createOrUpdate",
      serverRaw.owner_checkups_create_or_update,
    ),
    owner_checkups_list: createPolicyChainForRoute(
      "ownerCheckupsListDispatch",
      routePolicies,
      "ownerCheckups",
      "list",
      serverRaw.owner_checkups_list,
    ),
    owner_insurance_get: createPolicyChainForRoute(
      "ownerInsuranceGetDispatch",
      routePolicies,
      "ownerInsurance",
      "get",
      serverRaw.owner_insurance_get,
    ),
    owner_insurance_update: createPolicyChainForRoute(
      "ownerInsuranceUpdateDispatch",
      routePolicies,
      "ownerInsurance",
      "update",
      serverRaw.owner_insurance_update,
    ),
  } as const;

  const dispatch = createPolicyChain(
    "PetStoreRouterDispatch",
    options.policies ?? [],
    async function (ctx, request, response, onRouteNotFound) {
      const url = new URL(request.url!, `http://${request.headers.host}`);
      let path = url.pathname;

      if (path.length === 0) {
        return onRouteNotFound(request, response);
      } else if (path.startsWith("/")) {
        path = path.slice(1);
        if (path.length === 0) {
          return onRouteNotFound(request, response);
        } else if (path.startsWith("pets")) {
          path = path.slice(4);
          if (path.length === 0) {
            switch (request.method) {
              case "POST":
                return routeHandlers.pets_create(ctx, request, response, pets);
              case "GET":
                return routeHandlers.pets_list(ctx, request, response, pets);
              default:
                return onRouteNotFound(request, response);
            }
          } else if (path.startsWith("/")) {
            path = path.slice(1);
            if (path.length === 0) {
              return onRouteNotFound(request, response);
            } else {
              let __pet_id_idx = path.indexOf("/");
              __pet_id_idx = __pet_id_idx === -1 ? path.length : __pet_id_idx;
              const petId = path.slice(0, __pet_id_idx);
              path = path.slice(__pet_id_idx);
              if (path.length === 0) {
                switch (request.method) {
                  case "GET":
                    return routeHandlers.pets_get(
                      ctx,
                      request,
                      response,
                      pets,
                      petId,
                    );
                  case "PATCH":
                    return routeHandlers.pets_update(
                      ctx,
                      request,
                      response,
                      pets,
                      petId,
                    );
                  case "DELETE":
                    return routeHandlers.pets_delete(
                      ctx,
                      request,
                      response,
                      pets,
                      petId,
                    );
                  default:
                    return onRouteNotFound(request, response);
                }
              } else if (path.startsWith("/")) {
                path = path.slice(1);
                if (path.length === 0) {
                  return onRouteNotFound(request, response);
                } else if (path.startsWith("checkups")) {
                  path = path.slice(8);
                  if (path.length === 0) {
                    switch (request.method) {
                      case "GET":
                        return routeHandlers.pet_checkups_list(
                          ctx,
                          request,
                          response,
                          petCheckups,
                          petId,
                        );
                      default:
                        return onRouteNotFound(request, response);
                    }
                  } else if (path.startsWith("/")) {
                    path = path.slice(1);
                    if (path.length === 0) {
                      return onRouteNotFound(request, response);
                    } else {
                      let __checkup_id_idx = path.indexOf("/");
                      __checkup_id_idx =
                        __checkup_id_idx === -1
                          ? path.length
                          : __checkup_id_idx;
                      const checkupId = path.slice(0, __checkup_id_idx);
                      path = path.slice(__checkup_id_idx);
                      if (path.length === 0) {
                        switch (request.method) {
                          case "PATCH":
                            return routeHandlers.pet_checkups_create_or_update(
                              ctx,
                              request,
                              response,
                              petCheckups,
                              petId,
                              checkupId,
                            );
                          default:
                            return onRouteNotFound(request, response);
                        }
                      } else {
                        return onRouteNotFound(request, response);
                      }
                    }
                  }
                } else if (path.startsWith("insurance")) {
                  path = path.slice(9);
                  if (path.length === 0) {
                    switch (request.method) {
                      case "GET":
                        return routeHandlers.pet_insurance_get(
                          ctx,
                          request,
                          response,
                          petInsurance,
                          petId,
                        );
                      case "PATCH":
                        return routeHandlers.pet_insurance_update(
                          ctx,
                          request,
                          response,
                          petInsurance,
                          petId,
                        );
                      default:
                        return onRouteNotFound(request, response);
                    }
                  } else {
                    return onRouteNotFound(request, response);
                  }
                } else if (path.startsWith("toys")) {
                  path = path.slice(4);
                  if (path.length === 0) {
                    switch (request.method) {
                      case "GET":
                        return routeHandlers.toys_list(
                          ctx,
                          request,
                          response,
                          toys,
                          petId,
                        );
                      default:
                        return onRouteNotFound(request, response);
                    }
                  } else if (path.startsWith("/")) {
                    path = path.slice(1);
                    if (path.length === 0) {
                      return onRouteNotFound(request, response);
                    } else {
                      let __toy_id_idx = path.indexOf("/");
                      __toy_id_idx =
                        __toy_id_idx === -1 ? path.length : __toy_id_idx;
                      const toyId = path.slice(0, __toy_id_idx);
                      path = path.slice(__toy_id_idx);
                      if (path.length === 0) {
                        switch (request.method) {
                          case "GET":
                            return routeHandlers.toys_get(
                              ctx,
                              request,
                              response,
                              toys,
                              petId,
                              toyId,
                            );
                          default:
                            return onRouteNotFound(request, response);
                        }
                      } else if (path.startsWith("/insurance")) {
                        path = path.slice(10);
                        if (path.length === 0) {
                          switch (request.method) {
                            case "GET":
                              return routeHandlers.toy_insurance_get(
                                ctx,
                                request,
                                response,
                                toyInsurance,
                                petId,
                                toyId,
                              );
                            case "PATCH":
                              return routeHandlers.toy_insurance_update(
                                ctx,
                                request,
                                response,
                                toyInsurance,
                                petId,
                                toyId,
                              );
                            default:
                              return onRouteNotFound(request, response);
                          }
                        } else {
                          return onRouteNotFound(request, response);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        } else if (path.startsWith("checkups")) {
          path = path.slice(8);
          if (path.length === 0) {
            switch (request.method) {
              case "GET":
                return routeHandlers.checkups_list(
                  ctx,
                  request,
                  response,
                  checkups,
                );
              default:
                return onRouteNotFound(request, response);
            }
          } else if (path.startsWith("/")) {
            path = path.slice(1);
            if (path.length === 0) {
              return onRouteNotFound(request, response);
            } else {
              let __checkup_id_idx = path.indexOf("/");
              __checkup_id_idx =
                __checkup_id_idx === -1 ? path.length : __checkup_id_idx;
              const checkupId = path.slice(0, __checkup_id_idx);
              path = path.slice(__checkup_id_idx);
              if (path.length === 0) {
                switch (request.method) {
                  case "PATCH":
                    return routeHandlers.checkups_create_or_update(
                      ctx,
                      request,
                      response,
                      checkups,
                      checkupId,
                    );
                  default:
                    return onRouteNotFound(request, response);
                }
              } else {
                return onRouteNotFound(request, response);
              }
            }
          }
        } else if (path.startsWith("owners")) {
          path = path.slice(6);
          if (path.length === 0) {
            switch (request.method) {
              case "POST":
                return routeHandlers.owners_create(
                  ctx,
                  request,
                  response,
                  owners,
                );
              case "GET":
                return routeHandlers.owners_list(
                  ctx,
                  request,
                  response,
                  owners,
                );
              default:
                return onRouteNotFound(request, response);
            }
          } else if (path.startsWith("/")) {
            path = path.slice(1);
            if (path.length === 0) {
              return onRouteNotFound(request, response);
            } else {
              let __owner_id_idx = path.indexOf("/");
              __owner_id_idx =
                __owner_id_idx === -1 ? path.length : __owner_id_idx;
              const ownerId = path.slice(0, __owner_id_idx);
              path = path.slice(__owner_id_idx);
              if (path.length === 0) {
                switch (request.method) {
                  case "GET":
                    return routeHandlers.owners_get(
                      ctx,
                      request,
                      response,
                      owners,
                      ownerId,
                    );
                  case "PATCH":
                    return routeHandlers.owners_update(
                      ctx,
                      request,
                      response,
                      owners,
                      ownerId,
                    );
                  case "DELETE":
                    return routeHandlers.owners_delete(
                      ctx,
                      request,
                      response,
                      owners,
                      ownerId,
                    );
                  default:
                    return onRouteNotFound(request, response);
                }
              } else if (path.startsWith("/")) {
                path = path.slice(1);
                if (path.length === 0) {
                  return onRouteNotFound(request, response);
                } else if (path.startsWith("checkups")) {
                  path = path.slice(8);
                  if (path.length === 0) {
                    switch (request.method) {
                      case "GET":
                        return routeHandlers.owner_checkups_list(
                          ctx,
                          request,
                          response,
                          ownerCheckups,
                          ownerId,
                        );
                      default:
                        return onRouteNotFound(request, response);
                    }
                  } else if (path.startsWith("/")) {
                    path = path.slice(1);
                    if (path.length === 0) {
                      return onRouteNotFound(request, response);
                    } else {
                      let __checkup_id_idx = path.indexOf("/");
                      __checkup_id_idx =
                        __checkup_id_idx === -1
                          ? path.length
                          : __checkup_id_idx;
                      const checkupId = path.slice(0, __checkup_id_idx);
                      path = path.slice(__checkup_id_idx);
                      if (path.length === 0) {
                        switch (request.method) {
                          case "PATCH":
                            return routeHandlers.owner_checkups_create_or_update(
                              ctx,
                              request,
                              response,
                              ownerCheckups,
                              ownerId,
                              checkupId,
                            );
                          default:
                            return onRouteNotFound(request, response);
                        }
                      } else {
                        return onRouteNotFound(request, response);
                      }
                    }
                  }
                } else if (path.startsWith("insurance")) {
                  path = path.slice(9);
                  if (path.length === 0) {
                    switch (request.method) {
                      case "GET":
                        return routeHandlers.owner_insurance_get(
                          ctx,
                          request,
                          response,
                          ownerInsurance,
                          ownerId,
                        );
                      case "PATCH":
                        return routeHandlers.owner_insurance_update(
                          ctx,
                          request,
                          response,
                          ownerInsurance,
                          ownerId,
                        );
                      default:
                        return onRouteNotFound(request, response);
                    }
                  } else {
                    return onRouteNotFound(request, response);
                  }
                }
              }
            }
          }
        }
      }

      return onRouteNotFound(request, response);
    },
  );

  return {
    dispatch(request, response) {
      return dispatch(
        { request, response },
        request,
        response,
        onRouteNotFound,
      ).catch((e) => onInternalError(e, request, response));
    },
    expressMiddleware: function (request, response, next) {
      void dispatch({ request, response }, request, response, function () {
        next();
      }).catch((e) => onInternalError(e, request, response));
    },
  };
}
