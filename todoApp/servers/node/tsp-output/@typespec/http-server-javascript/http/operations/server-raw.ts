// Generated by Microsoft TypeSpec

import * as http from "node:http";

import { HttpContext } from "../../helpers/router.js";

import { UsersOperations } from "../../models/all/todo/users.js";

import {
  User,
  ToDoItemMultipartRequest,
  TodoUrlAttachment,
  TodoFileAttachment,
} from "../../models/all/todo/index.js";

import {
  TodoItemsOperations,
  TodoPage,
  TodoItemPatch,
} from "../../models/all/todo/todo-items/index.js";

import { CreateJsonRequestBody } from "../../models/synthetic.js";

import { AttachmentsOperations } from "../../models/all/todo/todo-items/attachments.js";

export async function users_operations_create(
  ctx: HttpContext,
  request: http.IncomingMessage,
  response: http.ServerResponse,
  operations: UsersOperations,
): Promise<void> {
  if (!request.headers["content-type"]?.startsWith("application/json")) {
    throw new Error(
      `Invalid Request: expected content-type 'application/json' but got '${request.headers["content-type"]?.split(";", 2)[0]}'.`,
    );
  }

  const user = (await new Promise(function parseUser(resolve, reject) {
    const chunks: Array<Buffer> = [];
    request.on("data", function appendChunk(chunk) {
      chunks.push(chunk);
    });
    request.on("end", function finalize() {
      resolve(JSON.parse(Buffer.concat(chunks).toString()));
    });
  })) as User;

  const result = await operations.create(ctx, user);

  if ("statusCode" in result && result.statusCode === 200) {
    response.statusCode = result.statusCode;
    delete (result as any).statusCode;
    response.end(JSON.stringify(result));
  } else if ("statusCode" in result && result.statusCode === 409) {
    response.statusCode = result.statusCode;
    delete (result as any).statusCode;
    response.end(JSON.stringify(result));
  } else if ("statusCode" in result && result.statusCode === 422) {
    response.statusCode = result.statusCode;
    delete (result as any).statusCode;
    response.end(JSON.stringify(result));
  } else if (
    "statusCode" in result &&
    result.statusCode >= 400 &&
    result.statusCode <= 499
  ) {
    response.statusCode = result.statusCode;
    delete (result as any).statusCode;
    response.end();
  } else if (
    "statusCode" in result &&
    result.statusCode >= 500 &&
    result.statusCode <= 599
  ) {
    response.statusCode = result.statusCode;
    delete (result as any).statusCode;
    response.end();
  }
}

export async function todo_items_operations_list(
  ctx: HttpContext,
  request: http.IncomingMessage,
  response: http.ServerResponse,
  operations: TodoItemsOperations,
): Promise<void> {
  const __query_params = new URLSearchParams(
    request.url!.split("?", 1)[1] ?? "",
  );

  const limit = __query_params.get("limit") ?? undefined;
  const offset = __query_params.get("offset") ?? undefined;
  const result = await operations.list(ctx, {
    limit: Number(limit),
    offset: Number(offset),
  });

  if ("items" in result) {
    response.end(JSON.stringify(TodoPage.toJsonObject(result as TodoPage)));
  } else if (
    "statusCode" in result &&
    result.statusCode >= 400 &&
    result.statusCode <= 499
  ) {
    response.statusCode = result.statusCode;
    delete (result as any).statusCode;
    response.end();
  } else if (
    "statusCode" in result &&
    result.statusCode >= 500 &&
    result.statusCode <= 599
  ) {
    response.statusCode = result.statusCode;
    delete (result as any).statusCode;
    response.end();
  }
}

export async function todo_items_operations_create_json(
  ctx: HttpContext,
  request: http.IncomingMessage,
  response: http.ServerResponse,
  operations: TodoItemsOperations,
): Promise<void> {
  const contentType = request.headers["Content-Type"] as string | undefined;
  if (contentType === undefined) {
    throw new Error("Invalid request: missing required header 'Content-Type'.");
  }

  if (!request.headers["content-type"]?.startsWith("application/json")) {
    throw new Error(
      `Invalid Request: expected content-type 'application/json' but got '${request.headers["content-type"]?.split(";", 2)[0]}'.`,
    );
  }

  const createJsonRequestBody = (await new Promise(
    function parseCreateJsonRequestBody(resolve, reject) {
      const chunks: Array<Buffer> = [];
      request.on("data", function appendChunk(chunk) {
        chunks.push(chunk);
      });
      request.on("end", function finalize() {
        resolve(JSON.parse(Buffer.concat(chunks).toString()));
      });
    },
  )) as CreateJsonRequestBody;

  const result = await operations.createJson(ctx, createJsonRequestBody.item, {
    attachments: createJsonRequestBody.attachments,
  });

  if ("id" in result) {
    response.end(JSON.stringify(result));
  } else if ("statusCode" in result && result.statusCode === 422) {
    response.statusCode = result.statusCode;
    delete (result as any).statusCode;
    response.end();
  } else if (
    "statusCode" in result &&
    result.statusCode >= 400 &&
    result.statusCode <= 499
  ) {
    response.statusCode = result.statusCode;
    delete (result as any).statusCode;
    response.end();
  } else if (
    "statusCode" in result &&
    result.statusCode >= 500 &&
    result.statusCode <= 599
  ) {
    response.statusCode = result.statusCode;
    delete (result as any).statusCode;
    response.end();
  }
}

export async function todo_items_operations_create_form(
  ctx: HttpContext,
  request: http.IncomingMessage,
  response: http.ServerResponse,
  operations: TodoItemsOperations,
): Promise<void> {
  const contentType = request.headers["Content-Type"] as string | undefined;
  if (contentType === undefined) {
    throw new Error("Invalid request: missing required header 'Content-Type'.");
  }

  if (!request.headers["content-type"]?.startsWith("multipart/form-data")) {
    throw new Error(
      `Invalid Request: expected content-type 'multipart/form-data' but got '${request.headers["content-type"]?.split(";", 2)[0]}'.`,
    );
  }

  const body = (await new Promise(function parseBodyMultipartRequest(
    resolve,
    reject,
  ) {
    const boundary = request.headers["content-type"]
      ?.split(";")
      .find((s) => s.includes("boundary="))
      ?.split("=", 2)[1];
    if (!boundary) {
      return reject("Invalid request: missing boundary in content-type.");
    }

    const chunks: Array<Buffer> = [];
    request.on("data", function appendChunk(chunk) {
      chunks.push(chunk);
    });
    request.on("end", function finalize() {
      const text = Buffer.concat(chunks).toString();
      const parts = text.split(boundary).slice(1, -1);
      const fields: { [k: string]: any } = {};

      for (const part of parts) {
        const [headerText, body] = part.split("\r\n\r\n", 2);
        const headers = Object.fromEntries(
          headerText.split("\r\n").map((line) => line.split(": ", 2)),
        ) as { [k: string]: string };
        const name = headers["Content-Disposition"]
          .split('name="')[1]
          .split('"')[0];
        const contentType = headers["Content-Type"] ?? "text/plain";

        switch (contentType) {
          case "application/json":
            fields[name] = JSON.parse(body);
            break;
          case "application/octet-stream":
            fields[name] = Buffer.from(body, "utf-8");
            break;
          default:
            fields[name] = body;
        }
      }

      resolve(fields as ToDoItemMultipartRequest);
    });
  })) as ToDoItemMultipartRequest;

  const result = await operations.createForm(ctx, body);

  if ("id" in result) {
    response.end(JSON.stringify(result));
  } else if ("statusCode" in result && result.statusCode === 422) {
    response.statusCode = result.statusCode;
    delete (result as any).statusCode;
    response.end();
  } else if (
    "statusCode" in result &&
    result.statusCode >= 400 &&
    result.statusCode <= 499
  ) {
    response.statusCode = result.statusCode;
    delete (result as any).statusCode;
    response.end();
  } else if (
    "statusCode" in result &&
    result.statusCode >= 500 &&
    result.statusCode <= 599
  ) {
    response.statusCode = result.statusCode;
    delete (result as any).statusCode;
    response.end();
  }
}

export async function todo_items_operations_get(
  ctx: HttpContext,
  request: http.IncomingMessage,
  response: http.ServerResponse,
  operations: TodoItemsOperations,
  id: string,
): Promise<void> {
  const result = await operations.get(ctx, Number(id));

  if ("id" in result) {
    response.end(JSON.stringify(result));
  } else if ("statusCode" in result && result.statusCode === 404) {
    response.statusCode = result.statusCode;
    delete (result as any).statusCode;
    response.end(JSON.stringify(result));
  }
}

export async function todo_items_operations_update(
  ctx: HttpContext,
  request: http.IncomingMessage,
  response: http.ServerResponse,
  operations: TodoItemsOperations,
  id: string,
): Promise<void> {
  const contentType = request.headers["Content-Type"] as string | undefined;
  if (contentType === undefined) {
    throw new Error("Invalid request: missing required header 'Content-Type'.");
  }

  if (
    !request.headers["content-type"]?.startsWith("application/merge-patch+json")
  ) {
    throw new Error(
      `Invalid Request: expected content-type 'application/merge-patch+json' but got '${request.headers["content-type"]?.split(";", 2)[0]}'.`,
    );
  }

  const patch = (await new Promise(function parsePatch(resolve, reject) {
    const chunks: Array<Buffer> = [];
    request.on("data", function appendChunk(chunk) {
      chunks.push(chunk);
    });
    request.on("end", function finalize() {
      resolve(JSON.parse(Buffer.concat(chunks).toString()));
    });
  })) as TodoItemPatch;

  const result = await operations.update(ctx, Number(id), patch);

  response.end(JSON.stringify(result));
}

export async function todo_items_operations_delete(
  ctx: HttpContext,
  request: http.IncomingMessage,
  response: http.ServerResponse,
  operations: TodoItemsOperations,
  id: string,
): Promise<void> {
  const result = await operations.delete(ctx, Number(id));

  if ("statusCode" in result && result.statusCode === 204) {
    response.statusCode = result.statusCode;
    delete (result as any).statusCode;
    response.end();
  } else if ("statusCode" in result && result.statusCode === 404) {
    response.statusCode = result.statusCode;
    delete (result as any).statusCode;
    response.end(JSON.stringify(result));
  } else if (
    "statusCode" in result &&
    result.statusCode >= 400 &&
    result.statusCode <= 499
  ) {
    response.statusCode = result.statusCode;
    delete (result as any).statusCode;
    response.end();
  } else if (
    "statusCode" in result &&
    result.statusCode >= 500 &&
    result.statusCode <= 599
  ) {
    response.statusCode = result.statusCode;
    delete (result as any).statusCode;
    response.end();
  }
}

export async function attachments_operations_list(
  ctx: HttpContext,
  request: http.IncomingMessage,
  response: http.ServerResponse,
  operations: AttachmentsOperations,
  itemId: string,
): Promise<void> {
  const result = await operations.list(ctx, Number(itemId));

  if ("items" in result) {
    response.end(JSON.stringify(result));
  } else if ("statusCode" in result && result.statusCode === 404) {
    response.statusCode = result.statusCode;
    delete (result as any).statusCode;
    response.end(JSON.stringify(result));
  } else if (
    "statusCode" in result &&
    result.statusCode >= 400 &&
    result.statusCode <= 499
  ) {
    response.statusCode = result.statusCode;
    delete (result as any).statusCode;
    response.end();
  } else if (
    "statusCode" in result &&
    result.statusCode >= 500 &&
    result.statusCode <= 599
  ) {
    response.statusCode = result.statusCode;
    delete (result as any).statusCode;
    response.end();
  }
}

export async function attachments_operations_create_url_attachment(
  ctx: HttpContext,
  request: http.IncomingMessage,
  response: http.ServerResponse,
  operations: AttachmentsOperations,
  itemId: string,
): Promise<void> {
  const contentType = request.headers["Content-Type"] as string | undefined;
  if (contentType === undefined) {
    throw new Error("Invalid request: missing required header 'Content-Type'.");
  }

  if (!request.headers["content-type"]?.startsWith("application/json")) {
    throw new Error(
      `Invalid Request: expected content-type 'application/json' but got '${request.headers["content-type"]?.split(";", 2)[0]}'.`,
    );
  }

  const contents = (await new Promise(function parseContents(resolve, reject) {
    const chunks: Array<Buffer> = [];
    request.on("data", function appendChunk(chunk) {
      chunks.push(chunk);
    });
    request.on("end", function finalize() {
      resolve(JSON.parse(Buffer.concat(chunks).toString()));
    });
  })) as TodoUrlAttachment;

  const result = await operations.createUrlAttachment(
    ctx,
    Number(itemId),
    contents,
  );

  if ("statusCode" in result && result.statusCode === 204) {
    response.statusCode = result.statusCode;
    delete (result as any).statusCode;
    response.end();
  } else if ("statusCode" in result && result.statusCode === 404) {
    response.statusCode = result.statusCode;
    delete (result as any).statusCode;
    response.end();
  } else if (
    "statusCode" in result &&
    result.statusCode >= 400 &&
    result.statusCode <= 499
  ) {
    response.statusCode = result.statusCode;
    delete (result as any).statusCode;
    response.end();
  } else if (
    "statusCode" in result &&
    result.statusCode >= 500 &&
    result.statusCode <= 599
  ) {
    response.statusCode = result.statusCode;
    delete (result as any).statusCode;
    response.end();
  }
}

export async function attachments_operations_create_file_attachment(
  ctx: HttpContext,
  request: http.IncomingMessage,
  response: http.ServerResponse,
  operations: AttachmentsOperations,
  itemId: string,
): Promise<void> {
  const contentType = request.headers["Content-Type"] as string | undefined;
  if (contentType === undefined) {
    throw new Error("Invalid request: missing required header 'Content-Type'.");
  }

  if (!request.headers["content-type"]?.startsWith("multipart/form-data")) {
    throw new Error(
      `Invalid Request: expected content-type 'multipart/form-data' but got '${request.headers["content-type"]?.split(";", 2)[0]}'.`,
    );
  }

  const contents = (await new Promise(function parseContentsMultipartRequest(
    resolve,
    reject,
  ) {
    const boundary = request.headers["content-type"]
      ?.split(";")
      .find((s) => s.includes("boundary="))
      ?.split("=", 2)[1];
    if (!boundary) {
      return reject("Invalid request: missing boundary in content-type.");
    }

    const chunks: Array<Buffer> = [];
    request.on("data", function appendChunk(chunk) {
      chunks.push(chunk);
    });
    request.on("end", function finalize() {
      const text = Buffer.concat(chunks).toString();
      const parts = text.split(boundary).slice(1, -1);
      const fields: { [k: string]: any } = {};

      for (const part of parts) {
        const [headerText, body] = part.split("\r\n\r\n", 2);
        const headers = Object.fromEntries(
          headerText.split("\r\n").map((line) => line.split(": ", 2)),
        ) as { [k: string]: string };
        const name = headers["Content-Disposition"]
          .split('name="')[1]
          .split('"')[0];
        const contentType = headers["Content-Type"] ?? "text/plain";

        switch (contentType) {
          case "application/json":
            fields[name] = JSON.parse(body);
            break;
          case "application/octet-stream":
            fields[name] = Buffer.from(body, "utf-8");
            break;
          default:
            fields[name] = body;
        }
      }

      resolve(fields as TodoFileAttachment);
    });
  })) as TodoFileAttachment;

  const result = await operations.createFileAttachment(
    ctx,
    Number(itemId),
    contents,
  );

  if ("statusCode" in result && result.statusCode === 204) {
    response.statusCode = result.statusCode;
    delete (result as any).statusCode;
    response.end();
  } else if ("statusCode" in result && result.statusCode === 404) {
    response.statusCode = result.statusCode;
    delete (result as any).statusCode;
    response.end();
  } else if (
    "statusCode" in result &&
    result.statusCode >= 400 &&
    result.statusCode <= 499
  ) {
    response.statusCode = result.statusCode;
    delete (result as any).statusCode;
    response.end();
  } else if (
    "statusCode" in result &&
    result.statusCode >= 500 &&
    result.statusCode <= 599
  ) {
    response.statusCode = result.statusCode;
    delete (result as any).statusCode;
    response.end();
  }
}
