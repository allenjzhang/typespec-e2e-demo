// Generated by Microsoft TypeSpec

import * as http from "node:http";

import * as serverRaw from "./operations/server-raw.js";

import { UsersOperations } from "../models/all/todo/users.js";

import { TodoItemsOperations } from "../models/all/todo/todo-items/index.js";

import { AttachmentsOperations } from "../models/all/todo/todo-items/attachments.js";

import {
  RouterOptions,
  createPolicyChain,
  createPolicyChainForRoute,
  HttpContext,
} from "../helpers/router.js";

export interface TodoRouter {
  /**
   * Dispatches the request to the appropriate service based on the request path.
   *
   * This member function may be used directly as a handler for a Node HTTP server.
   *
   * @param request - The incoming HTTP request.
   * @param response - The outgoing HTTP response.
   */
  dispatch(request: http.IncomingMessage, response: http.ServerResponse): void;

  /**
   * An Express middleware function that dispatches the request to the appropriate service based on the request path.
   *
   * This member function may be used directly as an application-level middleware function in an Express app.
   *
   * If the router does not match a route, it will call the `next` middleware registered with the application,
   * so it is sensible to insert this middleware at the beginning of the middleware stack.
   *
   * @param req - The incoming HTTP request.
   * @param res - The outgoing HTTP response.
   * @param next - The next middleware function in the stack.
   */
  expressMiddleware(
    req: http.IncomingMessage,
    res: http.ServerResponse,
    next: () => void,
  ): void;
}

export function createTodoRouter(
  usersOperations: UsersOperations,
  todoItemsOperations: TodoItemsOperations,
  attachmentsOperations: AttachmentsOperations,
  options: RouterOptions<{
    usersOperations: UsersOperations<HttpContext>;
    todoItemsOperations: TodoItemsOperations<HttpContext>;
    attachmentsOperations: AttachmentsOperations<HttpContext>;
  }> = {},
): TodoRouter {
  const onRouteNotFound =
    options.onRequestNotFound ??
    ((request, response) => {
      response.statusCode = 404;
      response.setHeader("Content-Type", "text/plain");
      response.end("Not Found");
    });

  const onInvalidRequest =
    options.onInvalidRequest ??
    ((request, response, route, error) => {
      response.statusCode = 400;
      response.setHeader("Content-Type", "application/json");
      response.end(JSON.stringify({ error }));
    });

  const onInternalError =
    options.onInternalError ??
    ((error, request, response) => {
      response.statusCode = 500;
      response.setHeader("Content-Type", "text/plain");
      response.end("Internal server error.");
    });

  const routePolicies = options.routePolicies ?? {};

  const routeHandlers = {
    users_operations_create: createPolicyChainForRoute(
      "usersOperationsCreateDispatch",
      routePolicies,
      "usersOperations",
      "create",
      serverRaw.users_operations_create,
    ),
    todo_items_operations_list: createPolicyChainForRoute(
      "todoItemsOperationsListDispatch",
      routePolicies,
      "todoItemsOperations",
      "list",
      serverRaw.todo_items_operations_list,
    ),
    todo_items_operations_create_json: createPolicyChainForRoute(
      "todoItemsOperationsCreateJsonDispatch",
      routePolicies,
      "todoItemsOperations",
      "createJson",
      serverRaw.todo_items_operations_create_json,
    ),
    todo_items_operations_create_form: createPolicyChainForRoute(
      "todoItemsOperationsCreateFormDispatch",
      routePolicies,
      "todoItemsOperations",
      "createForm",
      serverRaw.todo_items_operations_create_form,
    ),
    todo_items_operations_get: createPolicyChainForRoute(
      "todoItemsOperationsGetDispatch",
      routePolicies,
      "todoItemsOperations",
      "get",
      serverRaw.todo_items_operations_get,
    ),
    todo_items_operations_update: createPolicyChainForRoute(
      "todoItemsOperationsUpdateDispatch",
      routePolicies,
      "todoItemsOperations",
      "update",
      serverRaw.todo_items_operations_update,
    ),
    todo_items_operations_delete: createPolicyChainForRoute(
      "todoItemsOperationsDeleteDispatch",
      routePolicies,
      "todoItemsOperations",
      "delete",
      serverRaw.todo_items_operations_delete,
    ),
    attachments_operations_list: createPolicyChainForRoute(
      "attachmentsOperationsListDispatch",
      routePolicies,
      "attachmentsOperations",
      "list",
      serverRaw.attachments_operations_list,
    ),
    attachments_operations_create_url_attachment: createPolicyChainForRoute(
      "attachmentsOperationsCreateUrlAttachmentDispatch",
      routePolicies,
      "attachmentsOperations",
      "createUrlAttachment",
      serverRaw.attachments_operations_create_url_attachment,
    ),
    attachments_operations_create_file_attachment: createPolicyChainForRoute(
      "attachmentsOperationsCreateFileAttachmentDispatch",
      routePolicies,
      "attachmentsOperations",
      "createFileAttachment",
      serverRaw.attachments_operations_create_file_attachment,
    ),
  } as const;

  const dispatch = createPolicyChain(
    "TodoRouterDispatch",
    options.policies ?? [],
    async function (ctx, request, response, onRouteNotFound) {
      const url = new URL(request.url!, `http://${request.headers.host}`);
      let path = url.pathname;

      if (path.length === 0) {
        return onRouteNotFound(request, response);
      } else if (path.startsWith("/")) {
        path = path.slice(1);
        if (path.length === 0) {
          return onRouteNotFound(request, response);
        } else if (path.startsWith("users")) {
          path = path.slice(5);
          if (path.length === 0) {
            switch (request.method) {
              case "POST":
                return routeHandlers.users_operations_create(
                  ctx,
                  request,
                  response,
                  usersOperations,
                );
              default:
                return onRouteNotFound(request, response);
            }
          } else {
            return onRouteNotFound(request, response);
          }
        } else if (path.startsWith("items")) {
          path = path.slice(5);
          if (path.length === 0) {
            switch (request.method) {
              case "GET":
                return routeHandlers.todo_items_operations_list(
                  ctx,
                  request,
                  response,
                  todoItemsOperations,
                );
              case "POST":
                const contentType = request.headers["content-type"];
                switch (contentType) {
                  case "application/json":
                    return routeHandlers.todo_items_operations_create_json(
                      ctx,
                      request,
                      response,
                      todoItemsOperations,
                    );
                  case "multipart/form-data":
                    return routeHandlers.todo_items_operations_create_form(
                      ctx,
                      request,
                      response,
                      todoItemsOperations,
                    );
                  default:
                    return onInvalidRequest(
                      request,
                      response,
                      "/items",
                      `No operation in route '/items' matched content-type "${contentType}"`,
                    );
                }
              default:
                return onRouteNotFound(request, response);
            }
          } else if (path.startsWith("/")) {
            path = path.slice(1);
            if (path.length === 0) {
              return onRouteNotFound(request, response);
            } else {
              let __param_idx = path.indexOf("/");
              __param_idx = __param_idx === -1 ? path.length : __param_idx;
              const param = path.slice(0, __param_idx);
              path = path.slice(__param_idx);
              const id = param;
              const itemId = param;
              if (path.length === 0) {
                switch (request.method) {
                  case "GET":
                    return routeHandlers.todo_items_operations_get(
                      ctx,
                      request,
                      response,
                      todoItemsOperations,
                      id,
                    );
                  case "PATCH":
                    return routeHandlers.todo_items_operations_update(
                      ctx,
                      request,
                      response,
                      todoItemsOperations,
                      id,
                    );
                  case "DELETE":
                    return routeHandlers.todo_items_operations_delete(
                      ctx,
                      request,
                      response,
                      todoItemsOperations,
                      id,
                    );
                  default:
                    return onRouteNotFound(request, response);
                }
              } else if (path.startsWith("/attachments")) {
                path = path.slice(12);
                if (path.length === 0) {
                  switch (request.method) {
                    case "GET":
                      return routeHandlers.attachments_operations_list(
                        ctx,
                        request,
                        response,
                        attachmentsOperations,
                        itemId,
                      );
                    case "POST":
                      const contentType = request.headers["content-type"];
                      switch (contentType) {
                        case "application/json":
                          return routeHandlers.attachments_operations_create_url_attachment(
                            ctx,
                            request,
                            response,
                            attachmentsOperations,
                            itemId,
                          );
                        case "multipart/form-data":
                          return routeHandlers.attachments_operations_create_file_attachment(
                            ctx,
                            request,
                            response,
                            attachmentsOperations,
                            itemId,
                          );
                        default:
                          return onInvalidRequest(
                            request,
                            response,
                            "/items/{itemId}/attachments",
                            `No operation in route '/items/{itemId}/attachments' matched content-type "${contentType}"`,
                          );
                      }
                    default:
                      return onRouteNotFound(request, response);
                  }
                } else {
                  return onRouteNotFound(request, response);
                }
              }
            }
          }
        }
      }

      return onRouteNotFound(request, response);
    },
  );

  return {
    dispatch(request, response) {
      return dispatch(
        { request, response },
        request,
        response,
        onRouteNotFound,
      ).catch((e) => onInternalError(e, request, response));
    },
    expressMiddleware: function (request, response, next) {
      void dispatch({ request, response }, request, response, function () {
        next();
      }).catch((e) => onInternalError(e, request, response));
    },
  };
}
